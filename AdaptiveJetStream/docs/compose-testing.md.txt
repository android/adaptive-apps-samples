# Compose testing

## Decisions

Ask the user if they want to run the tests locally using Robolectric or on devices using
instrumented tests. Robolectric is preferred for component tests as they are faster and require
less setup.

## Robolectric Setup

Set this property in the module's build file:

```groovy
android {
  testOptions {
    unitTests {
      isIncludeAndroidResources = true
    }
  }
}
```

And the following dependencies to the project:

- junit:junit
- org.robolectric:robolectric


## Compose Test Setup {:#setup}

First make sure the app is ready to run Compose tests.

The following dependencies must be added to the `build.gradle` file of the module
containing your UI tests:

```groovy
// Test rules and transitive dependencies:
androidTestImplementation("androidx.compose.ui:ui-test-junit4:$compose_version")
// Needed for createComposeRule(), but not for createAndroidComposeRule<YourActivity>():
debugImplementation("androidx.compose.ui:ui-test-manifest:$compose_version")
```

This module includes a [`ComposeTestRule`][10] and an implementation for Android
called [`AndroidComposeTestRule`][11]. Through this rule you can set Compose
content or access the activity. You construct the rules using factory functions,
either [`createComposeRule`][12] or, if you need access to an activity,
[`createAndroidComposeRule`][13]. A typical UI test for Compose looks like this:

```kotlin
// file: app/src/test/java/com/package/MyComposeTest.kt

class MyComposeTest {

    @get:Rule val composeTestRule = createComposeRule()
    // use createAndroidComposeRule<YourActivity>() if you need access to
    // an activity

    @Test
    fun myTest() {
        // Start the app
        composeTestRule.setContent {
            MyAppTheme {
                MainScreen(uiState = fakeUiState, /*...*/)
            }
        }

        composeTestRule.onNodeWithText("Continue").performClick()

        composeTestRule.onNodeWithText("Welcome").assertIsDisplayed()
    }
}
```

Note that the location of Robolectric tests is always the `test` source set, not `androidTest`.

### Finders {:#finders }

You can use [`onNode`][2] and [`onAllNodes`][3] to select one or multiple nodes
respectively, but you can also use convenience finders for the most common
searches, such as [`onNodeWithText`][4], and
[`onNodeWithContentDescription`][5]. You can browse the complete list in the
[Compose Testing cheat sheet][6].

#### Select a single node {:#select-single }

{# Pseudocode, taken from comment in AOSP file #}
```kotlin
composeTestRule.onNode(<<SemanticsMatcher>>, useUnmergedTree = false): SemanticsNodeInteraction
```

```kotlin
// Example
composeTestRule
    .onNode(hasText("Button")) // Equivalent to onNodeWithText("Button")
```

#### Select multiple nodes {:#select-multiple }

{# Pseudocode, taken from comment in AOSP file #}
```kotlin
composeTestRule
    .onAllNodes(<<SemanticsMatcher>>): SemanticsNodeInteractionCollection
```

```kotlin
// Example
composeTestRule
    .onAllNodes(hasText("Button")) // Equivalent to onAllNodesWithText("Button")
```

#### Unmerged tree {:#unmerged }

Some nodes merge the semantics information of their children. For example, a
button with two text elements merges the text element labels:

```kotlin
MyButton {
    Text("Hello")
    Text("World")
}
```

From a test, use [`printToLog()`][7] to show the semantics tree:

```kotlin
composeTestRule.onRoot().printToLog("TAG")
```

This code prints the following output:

```none
Node #1 at (...)px
 |-Node #2 at (...)px
   Role = 'Button'
   Text = '[Hello, World]'
   Actions = [OnClick, GetTextLayoutResult]
   MergeDescendants = 'true'
```

If you need to match a node of what would be the _unmerged_ tree, you can set
`useUnmergedTree` to `true`:

```kotlin
composeTestRule.onRoot(useUnmergedTree = true).printToLog("TAG")
```

This code prints the following output:

```none
Node #1 at (...)px
 |-Node #2 at (...)px
   OnClick = '...'
   MergeDescendants = 'true'
    |-Node #3 at (...)px
    | Text = '[Hello]'
    |-Node #5 at (83.0, 86.0, 191.0, 135.0)px
      Text = '[World]'
```

The `useUnmergedTree` parameter is available in all finders. For example, here
it's used in an `onNodeWithText` finder.

```kotlin
composeTestRule
    .onNodeWithText("World", useUnmergedTree = true).assertIsDisplayed()
```

### Assertions {:#assertions }

Check assertions by calling `assert()` on the [`SemanticsNodeInteraction`][8]
returned by a finder with one or multiple matchers:

```kotlin
// Single matcher:
composeTestRule
    .onNode(matcher)
    .assert(hasText("Button")) // hasText is a SemanticsMatcher

// Multiple matchers can use and / or
composeTestRule
    .onNode(matcher).assert(hasText("Button") or hasText("Button2"))
```

You can also use convenience functions for the most common assertions, such as
[`assertExists`][9], [`assertIsDisplayed`][10], and [`assertTextEquals`][11].
You can browse the complete list in the [Compose Testing cheat sheet][6].

There are also functions to check assertions on a collection of nodes:

```kotlin
// Check number of matched nodes
composeTestRule
    .onAllNodesWithContentDescription("Beatle").assertCountEquals(4)
// At least one matches
composeTestRule
    .onAllNodesWithContentDescription("Beatle").assertAny(hasTestTag("Drummer"))
// All of them match
composeTestRule
    .onAllNodesWithContentDescription("Beatle").assertAll(hasClickAction())
```

### Actions {:#actions }

To inject an action on a node, call a `perform…()` function:

{# Pseudocode, not in AOSP #}
```kotlin
composeTestRule.onNode(...).performClick()
```

Note: You cannot chain actions inside a perform function. Instead, make multiple
`perform…()` calls.

Here are some examples of actions:

```kotlin
performClick(),
performSemanticsAction(key),
performKeyPress(keyEvent),
performGesture { swipeLeft() }
```

You can browse the complete list in the
[Compose Testing cheat sheet][6].

### Matchers {:#matchers }

A variety of matchers are available for testing your Compose
code.

#### Hierarchical matchers {:#hierarchical-matchers }

Hierarchical matchers let you go up or down the semantics tree and perform
matching.

{# Pseudocode, not in AOSP #}
```kotlin
fun hasParent(matcher: SemanticsMatcher): SemanticsMatcher
fun hasAnySibling(matcher: SemanticsMatcher): SemanticsMatcher
fun hasAnyAncestor(matcher: SemanticsMatcher): SemanticsMatcher
fun hasAnyDescendant(matcher: SemanticsMatcher):  SemanticsMatcher
```

Here are some examples of these matchers being used:

```kotlin
composeTestRule.onNode(hasParent(hasText("Button")))
    .assertIsDisplayed()
```

#### Selectors {:#selectors }

An alternative way to create tests is to use _selectors_ which can make some
tests more readable.

```kotlin
composeTestRule.onNode(hasTestTag("Players"))
    .onChildren()
    .filter(hasClickAction())
    .assertCountEquals(4)
    .onFirst()
    .assert(hasText("John"))
```


# Common patterns

### Test in isolation

[`ComposeTestRule`](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/junit4/ComposeTestRule)lets you start an activity displaying any composable: your full application, a single screen, or a small element. It's also a good practice to check that your composables are correctly encapsulated and they work independently, allowing for easier and more focused UI testing.

This doesn't mean you should*only*create unit UI tests. UI tests scoping larger parts of your UI are also very important.

### Access the activity and resources after setting your own content

Oftentimes you need to set the content under test using`composeTestRule.setContent`and you also need to access activity resources, for example to assert that a displayed text matches a string resource. However, you can't call`setContent`on a rule created with`createAndroidComposeRule()`if the activity already calls it.

A common pattern to achieve this is to create an`AndroidComposeTestRule`using an empty activity such as[`ComponentActivity`](https://developer.android.com/reference/androidx/activity/ComponentActivity)).

    class MyComposeTest {

        @get:Rule
        val composeTestRule = createAndroidComposeRule<ComponentActivity>()

        @Test
        fun myTest() {
            // Start the app
            composeTestRule.setContent {
                MyAppTheme {
                    MainScreen(uiState = exampleUiState, /*...*/)
                }
            }
            val continueLabel = composeTestRule.activity.getString(R.string.next)
            composeTestRule.onNodeWithText(continueLabel).performClick()
        }
    }

Note that`ComponentActivity`needs to be added to your app's`AndroidManifest.xml`file. Enable that by adding this dependency to your module:

    debugImplementation("androidx.compose.ui:ui-test-manifest:$compose_version")

### Custom semantics properties

You can create custom[semantics](https://developer.android.com/develop/ui/compose/testing/semantics)properties to expose information to tests. To do this, define a new`SemanticsPropertyKey`and make it available using the`SemanticsPropertyReceiver`.

    // Creates a semantics property of type Long.
    val PickedDateKey = SemanticsPropertyKey<Long>("PickedDate")
    var SemanticsPropertyReceiver.pickedDate by PickedDateKey

Now use that property in the`semantics`modifier:

    val datePickerValue by remember { mutableStateOf(0L) }
    MyCustomDatePicker(
        modifier = Modifier.semantics { pickedDate = datePickerValue }
    )

From tests, use`SemanticsMatcher.expectValue`to assert the value of the property:

    composeTestRule
        .onNode(SemanticsMatcher.expectValue(PickedDateKey, 1445378400)) // 2015-10-21
        .assertExists()

| **Warning:** You should only use custom Semantics properties when it's hard to match a specific item using the given finders and matchers. Using custom Semantics properties to expose visual properties such as colors, font size or rounded corner radius is not recommended, as it can pollute production code and wrong implementations can lead to bugs that are hard to find.

### Verify state restoration

Verify that the state of your Compose elements is correctly restored when the activity or process is recreated. Perform such checks without relying on activity recreation with the[`StateRestorationTester`](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/junit4/StateRestorationTester)class.

This class lets you simulate the recreation of a composable. It's especially useful to verify the implementation of[`rememberSaveable`](https://developer.android.com/reference/kotlin/androidx/compose/runtime/saveable/package-summary#rememberSaveable(kotlin.Array,androidx.compose.runtime.saveable.Saver,kotlin.String,kotlin.Function0)).


    class MyStateRestorationTests {

        @get:Rule
        val composeTestRule = createComposeRule()

        @Test
        fun onRecreation_stateIsRestored() {
            val restorationTester = StateRestorationTester(composeTestRule)

            restorationTester.setContent { MainScreen() }

            // TODO: Run actions that modify the state

            // Trigger a recreation
            restorationTester.emulateSavedInstanceStateRestore()

            // TODO: Verify that state has been correctly restored.
        }
    }

### Test different device configurations

Android apps need to adapt to many changing conditions: window sizes, locales, font sizes, dark and light themes, and more. Most of these conditions are derived from device-level values controlled by the user and exposed with the current[`Configuration`](https://developer.android.com/reference/android/content/res/Configuration)instance. Testing different configurations directly in a test is difficult since the test must configure device-level properties.

[`DeviceConfigurationOverride`](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/DeviceConfigurationOverride)is a test-only API that lets you simulate different device configurations in a localized way for the`@Composable`content under test.

The companion object of`DeviceConfigurationOverride`has the following extension functions, which override device-level configuration properties:

- [`DeviceConfigurationOverride.DarkMode()`](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/DeviceConfigurationOverride.Companion#(androidx.compose.ui.test.DeviceConfigurationOverride.Companion).DarkMode(kotlin.Boolean)): Overrides the system to dark theme or light theme.
- [`DeviceConfigurationOverride.FontScale()`](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/DeviceConfigurationOverride.Companion#(androidx.compose.ui.test.DeviceConfigurationOverride.Companion).FontScale(kotlin.Float)): Overrides the[system font scale](https://developer.android.com/training/multiscreen/screendensities#TaskUseDP).
- [`DeviceConfigurationOverride.FontWeightAdjustment()`](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/DeviceConfigurationOverride.Companion#(androidx.compose.ui.test.DeviceConfigurationOverride.Companion).FontWeightAdjustment(kotlin.Int)): Overrides the system font weight adjustment.
- [`DeviceConfigurationOverride.ForcedSize()`](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/DeviceConfigurationOverride.Companion#(androidx.compose.ui.test.DeviceConfigurationOverride.Companion).ForcedSize(androidx.compose.ui.unit.DpSize)): Forces a specific amount of space regardless of device size.
- [`DeviceConfigurationOverride.LayoutDirection()`](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/DeviceConfigurationOverride.Companion#(androidx.compose.ui.test.DeviceConfigurationOverride.Companion).LayoutDirection(androidx.compose.ui.unit.LayoutDirection)): Overrides the[layout direction](https://developer.android.com/training/basics/supporting-devices/languages#SupportLayoutMirroring)(left-to-right or right-to-left).
- [`DeviceConfigurationOverride.Locales()`](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/DeviceConfigurationOverride.Companion#(androidx.compose.ui.test.DeviceConfigurationOverride.Companion).Locales(androidx.compose.ui.text.intl.LocaleList)): Overrides the[locale](https://developer.android.com/guide/topics/resources/localization).
- [`DeviceConfigurationOverride.RoundScreen()`](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/DeviceConfigurationOverride.Companion#(androidx.compose.ui.test.DeviceConfigurationOverride.Companion).RoundScreen(kotlin.Boolean)): Overrides if the screen is[round](https://developer.android.com/design/ui/wear/guides/foundations/getting-started#design-for-round).

To apply a specific override, wrap the content under test in a call to the[`DeviceConfigurationOverride()`](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/package-summary#DeviceConfigurationOverride(androidx.compose.ui.test.DeviceConfigurationOverride,kotlin.Function0))top-level function, passing the override to apply as a parameter.

For example, the following code applies the`DeviceConfigurationOverride.ForcedSize()`override to change the density locally, forcing the`MyScreen`composable to be rendered in a large landscape window, even if the device the test is running on doesn't support that window size directly:

<br />

```kotlin
composeTestRule.setContent {
    DeviceConfigurationOverride(
        DeviceConfigurationOverride.ForcedSize(DpSize(1280.dp, 800.dp))
    ) {
        MyScreen() // Will be rendered in the space for 1280dp by 800dp without clipping.
    }
}https://github.com/android/snippets/blob/aea6b599716bf76907c8df560ab1903f968e1031/compose/snippets/src/androidTest/java/com/example/compose/snippets/deviceconfigurationoverride/DeviceConfigurationOverrideSnippets.kt#L41-L47
```

<br />

To apply multiple overrides together, use[`DeviceConfigurationOverride.then()`](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/DeviceConfigurationOverride#(androidx.compose.ui.test.DeviceConfigurationOverride).then(androidx.compose.ui.test.DeviceConfigurationOverride)):

<br />

```kotlin
composeTestRule.setContent {
    DeviceConfigurationOverride(
        DeviceConfigurationOverride.FontScale(1.5f) then
            DeviceConfigurationOverride.FontWeightAdjustment(200)
    ) {
        Text(text = "text with increased scale and weight")
    }
}https://github.com/android/snippets/blob/aea6b599716bf76907c8df560ab1903f968e1031/compose/snippets/src/androidTest/java/com/example/compose/snippets/deviceconfigurationoverride/DeviceConfigurationOverrideSnippets.kt#L55-L62
```
